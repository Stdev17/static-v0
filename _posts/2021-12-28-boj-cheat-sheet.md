---
layout: post
title:  "BoJ Cheat Sheet (v211228.0)"
tags: ["Competitive Programming", "C++", "Cheat Sheet"]
---

거두절미하고, 이 포스트는 백준 문제풀이의 소소한 팁을 `C++17` 기준에서 정리했습니다. 혹시 다른 개발 언어를 사용하시더라도 상당수는 공통적으로 해당하리라 생각합니다. 저도 처음 문제풀이 과정을 익혀 나가면서 아주 trivial한 부분에서까지 시행착오를 많이 겪었었는데, 알게 된 정보를 이렇게 공유함으로써 여러분은 더욱 빠르게 정진할 수 있었으면 좋겠어요. 개발 생태계의 구성원끼리 이렇게 사다리를 쌓아 올려나가는 문화, 그리고 저도 이런 식으로나마 기여할 수 있다는 것이 하나의 구성원으로서 자랑스럽습니다.

## 주의사항
* 여기 있는 내용은 철저히 Competitive Programming/코딩 테스트용 문제풀이에 최적화된 접근이므로, 실제 코딩에는 안티패턴으로 작용하는 경우가 상당수입니다. 한편으로는 실제로도 나쁘지 않은 접근도 있습니다. 일독해 보시면서 어떤 이유에서 그러한지 같이 고민해 보아요.

### 목차
* 입출력, 포매팅
* 데이터 트리밍
* 자료구조
* 에러 찾기
* 코드 가독성

## 입출력, 포매팅

* cin/cout보다 `scanf/printf`가 더 빠르다. endl은 엄청 느리기 때문에 대신 `\n`을 사용해야 한다.
  endl은 개행 뿐만 아니라 출력 버퍼를 지워버리므로 오버헤드가 아주 큰 것이다.
  굳이 cin을 사용하려면 성능을 위해 `ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);`을 선언할 것.
* `while (scanf("%d", &n) != EOF)` - 테스트 케이스 n개를 받는다. 0 등으로 끝나면 EOF 대신 넣어도 되고.
    * n개의 입력을 받아 배열에 저장할 때는, for문을 돌린다.
* `scanf("%d.%d", &val1, &val2)` -  소수점은 어지간하면 정수형으로 받는 게 빠르다.
    * 특히, double은 부동 소수점 자료형이므로 정확한 값을 표현하기엔 위험하다. 유리수는 정수형으로 표현하는 것을 추천한다.
* `scanf("%3c%*c%d")` - 정해진 글자만큼 char 받기. *는 캐릭터 하나 무시하기. 이 포맷으로 ABC-1234를 한 번에 받을 수 있다. 이를 응용하면, 글자별로(맵으로) 주어지는 입력도 for loop로 받아낼 수 있다. (`for i, j scanf("%1d", &map[i][j])` - 물론 전역 배열에 받는다)
    * 문자 하나가 아닌, 2자리 이상의 숫자 등을 받을 때 실수로 %1d를 쓰지 않도록 한다. 공백이 아닌 문자로 나뉜다면, asterisk(*)를 활용해야 한다.
* `scanf(" %c")` - 이런 식으로 라인 피드를 제거할 수 있다. char는 \n이 남으므로 주의해야 한다. `getchar()`로 받아낼 수도 있다.
* `fgets(buf, size, stdin)`으로 문자열을 char 배열로 받을 수 있다. 아스키 코드와 관련해서, string을 char 배열이라고 해석하면 자료 조작이 유용해진다. 실제로 C++의 string이라는 자료형은 const char*를 추상화한 것이기도 하고.
* optional하게 데이터가 들쭉날쭉하면, `fgets(buf, MAX_SIZE, stdin)`과 `sscanf(buf, " %s %d", string, &int)`로 받아낸다. 그러면 숫자가 빠져도 바로 받아낼 수 있다.

## 데이터 트리밍

## 자료구조

## 에러 찾기

### 스택 오버플로우

* 배열은 결국 연속된 포인터들의 syntactic sugar임을 상기하자. 포인터의 크기는 4 byte, int의 크기는 4 byte므로, 스택에 대략 100,000개 정도의 int를 담는 배열까지 저장할 수 있을 것이다. struct의 크기는 `sizeof(struct)`로 알 수 있는데, struct의 멤버 중 가장 큰 자료형의 크기를 기준으로 padding이 발생한다.
    * 일반적으로 C++ 컴파일러에 설정된 스택 사이즈는 1MB를 넘지 않는다. 반면 힙 사이즈는 문제 조건마다 다르게 제시되는데, 사실상 모든 문제는 백준에서 제공하는 메모리 내에서 충분히 해결 가능하다. 스택은 컴파일 타임에 자료의 메모리 상 위치가 결정되어 있어 CPU에 캐싱이 쉽지만 태생적인 크기가 작아 자료의 양이 많아지면 스택 오버플로우가 발생할 수 있다. 힙은 런타임에 할당될 때마다 자료의 위치가 달라져 캐시 미스 빈도가 올라 가고 segmentation fault의 위험성이 도사리고 있지만, 이 점을 활용하여 런타임에 크기가 결정되는 변수를 도라에몽 주머니처럼 자유롭게 할당 가능하다. 다시 말하지만, 바로 이 점 때문에 segfault 위험성이 있다!

## 코드 가독성
### 상수, 변수, 구조체
* 상수는 전역으로 보기 좋게 정리해 둔다. (`const int MAX_COUNT = 10000;`)